 #    

```
---
layout: post
title: ``"APP黑白化探索与实践"
subtitle: ``"APP黑白化探索与实践"
author: ``"yangdingguo"
tags:
 ``- Android
 ``- 黑白化
---
```

 #               APP黑白化探索与实践



## 前情提要

 清明假期期间需要对app 界面做黑白化处理，以示对疫情期间亡者的尊重。



## 实现方案一：

​        梳理所有页面相关元素，对所有页面元素，字体、图片及背景进行梳理，UED重新给出设计切图后 重新进行开发替换。

方案缺点：

* 开发周期长，需要逐个页面梳理替换
* SDK内部页面无法适配

---------



 ## 实现方案二：

​        方案一从懒人的角度看问题，接下来从技术角度来看，通过自定义控件，通过代码实现黑白化。通过paint 、ColorMatrix 画图实现黑白化的原理如下：

​        先看ColorMatrix setSaturation 源码注释：

```java
  /**
   * Set the matrix to affect the saturation of colors.
   * @param sat A value of 0 maps the color to gray-scale. 1 is       identity.
   */
  public void setSaturation(float sat) {
      reset();
      float[] m = mArray;

      final float invSat = 1 - sat;
      final float R = 0.213f * invSat;
      final float G = 0.715f * invSat;
      final float B = 0.072f * invSat;

      m[0] = R + sat; m[1] = G;       m[2] = B;
      m[5] = R;       m[6] = G + sat; m[7] = B;
      m[10] = R;      m[11] = G;      m[12] = B + sat;
  }
```

​         可以看到参数设置，如果设置sat = 0,则此时是做黑白化处理，那么就可以通过自定义控件（Button/TextView/ImageView）等设置paint 的colorFilter 达到黑白化的效果。

```java
public GrayTextView(@NonNull Context context, @Nullable   AttributeSet attrs) {
    super(context, attrs);
    ColorMatrix cm = new ColorMatrix();
    cm.setSaturation(0);
    mPaint.setColorFilter(new ColorMatrixColorFilter(cm));
 }

public GrayTextView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
 }
@Override
protected void onDraw(Canvas canvas) {
     canvas.saveLayer(null,mPaint,Canvas.ALL_SAVE_FLAG);
     super.onDraw(canvas);
     canvas.restore();
 }
```

​        上述代码是自定义TextView ,通过在构造函数中设置paint,在onDraw 中将paint 设置给canvas,控件绘制时达到黑白化效果。自定义控件替换android 原生控件。

优点：

* 不依赖UI切图，纯技术修改

缺点：

* 自定义控件多
* 依赖的三方自定义控件也需要重写，改动范围较大

--------



## 实现方案三：

​		在方案二的基础既然可以对所有控件重写onDraw方法达到实现黑白化的效果，那么ViewGroup设置Paint 和 Canvas后是否具有透传性？是否可以只更换页面的父布局就可以达到黑白效果？

​        我们activity setContentView的父布局是android:id/content,也就是FrameLayout,我们可以在页面创建绘制前把这个布局替换成我们的GrayFrameLayout 。

​        GrayFrameLayout 代码如下：

​       

```java
public GrayFrameLayout(@NonNull Context context, @Nullable AttributeSet attrs) {
    super(context, attrs);
    ColorMatrix cm = new ColorMatrix();
    cm.setSaturation(0);
    mPaint.setColorFilter(new ColorMatrixColorFilter(cm));
}

public GrayFrameLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
}
@Override
protected void onDraw(Canvas canvas) {
    canvas.saveLayer(null,mPaint,Canvas.ALL_SAVE_FLAG);
    super.onDraw(canvas);
    canvas.restore();
}
//此处代码不可省掉 这里将设置的paint 和 canvas 分发给布局内的子元素
@Override
protected void dispatchDraw(Canvas canvas) {
    canvas.saveLayer(null,mPaint,Canvas.ALL_SAVE_FLAG);
    super.dispatchDraw(canvas);
    canvas.restore();
}
```

​		可以看到上述代码和基本view一样覆写了构造函数和onDraw外，还覆写了dispachDraw,通过dispatchDraw 将canvas 分发给子元素达到黑白效果。

​       如果app 自定义了BaseActivity,可以在基类的onCreate 中设置如下代码即可达到app 全局黑白化效果。

```java
 @Override
    public View onCreateView(String name, Context context, AttributeSet attrs) {
        
        if ("FrameLayout".equals(name)) {
            int count = attrs.getAttributeCount();
            for (int i = 0; i < count; i++) {
                String attrName = attrs.getAttributeName(i);
                String attrValue = attrs.getAttributeValue(i);
                if (attrName.equals("id")) {
                    int id = Integer.parseInt(attrValue.substring(1));
                    String idValue = getResources().getResourceName(id);
                    if ("android:id/content".equals(idValue)) {
                        //替换成自定义的GrayFrameLayout 达到黑白化的效果
                        GrayFrameLayout grayFramLayout = new GrayFrameLayout(context, attrs);
                        return grayFramLayout;
                    }
                    
                }
                
            }
        }
        return super.onCreateView(name, context, attrs);
    }
```

   优点：

       * 减少自定义控件数量
       * dialog也可以达到黑白化处理方案

  缺点：

* 此种方式修改包含webview 显示的页面会有显示问题 
* 对于SDK内部的三方界面无法兼容
* 需要自定义GrayFrameLayout （可能导致webview 黑白化后显示异常）

----



## 实现方案四：

​		基于方案三,对于方案三的缺点提出以下构想，content的上一层是DecorView,可以在DecorView 上动脑筋么？如果没有基类，可以监听所有activity的生命周期么？。

​       本方案实现代码如下在app application onCreate中添加如下代码，基于ActivityLifeCycleCallbacks ：

​      

```java
if (mActivityLifecycleCallbacks != null) {
    unregisterActivityLifecycleCallbacks(mActivityLifecycleCallbacks);
}
mActivityLifecycleCallbacks = new ActivityLifecycleCallbacks() {
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
        
        if (activity.getWindow() != null && activity.getWindow().getDecorView() != null) {
            Paint mPaint = new Paint();
            ColorMatrix cm = new ColorMatrix();
            cm.setSaturation(0);
            mPaint.setColorFilter(new ColorMatrixColorFilter(cm));
            activity.getWindow().getDecorView().setLayerType(View.LAYER_TYPE_HARDWARE, mPaint);
        }
    }
    //这里省略其他生命周期函数
};
registerActivityLifecycleCallbacks(mActivityLifecycleCallbacks);
```

   优点：

       * webview 黑白化显示正常
       * SDK内Activity 页面黑白化显示正常
       * 无需自定义控件

  缺点：

* dilaog 黑白化失效

-------

## 实现方案五：

​        方案三和方案四结合，结合LayoutInflater.setFactory2 (具体原理读者可以自行查阅相关文档)。如果activity 基类集成继承的是AppCompatActivity,重新调用setFactory2会抛出异常（读者可以自行查看AppCompatActivty 源码）。

​       本方案解决方案如下代码：

```java
if (mActivityLifecycleCallbacks != null) {
    unregisterActivityLifecycleCallbacks(mActivityLifecycleCallbacks);
}
mActivityLifecycleCallbacks = new ActivityLifecycleCallbacks() {
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
        
        if (activity == null) {
            return;
        }
        LayoutInflater layoutInflater = activity.getLayoutInflater();
        if (layoutInflater == null) {
            return;
        }
        // 解决基类是AppCompatActivity的兼容问题 做降级处理
        if (activity instanceof AppCompatActivity || layoutInflater.getFactory2() != null) {
            
            try {
                // 通过反射设置mFactorySet为false,以便下一步重新设置Factory2解决 nfc dialog无黑白化处理问题
                Field mFactorySet = LayoutInflater.class.getDeclaredField("mFactorySet");
                mFactorySet.setAccessible(true);
                mFactorySet.set(layoutInflater, false);
            } catch (Exception e) {
                // 反射异常时只对界面做黑白化处理 降级方案
                if (activity.getWindow() != null && activity.getWindow().getDecorView() != null) {
                    Paint mPaint = new Paint();
                    ColorMatrix cm = new ColorMatrix();
                    cm.setSaturation(0);
                    mPaint.setColorFilter(new ColorMatrixColorFilter(cm));
                     				activity.getWindow().getDecorView().setLayerType(View.LAYER_TYPE_HARDWARE, mPaint);
                }
                return;
            }
        }
        
        LayoutInflaterCompat.setFactory2(activity.getLayoutInflater(), new LayoutInflater.Factory2() {
            @Override
            public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
                
                // 方法进入即可对activity /fragment /dialog 做黑白化处理
                if ("FrameLayout".equals(name)) {
                    int count = attrs.getAttributeCount();
                    for (int i = 0; i < count; i++) {
                        String attrName = attrs.getAttributeName(i);
                        String attrValue = attrs.getAttributeValue(i);
                        if (attrName.equals("id")) {
                            int id = Integer.parseInt(attrValue.substring(1));
                            String idValue = getResources().getResourceName(id);
                            if ("android:id/content".equals(idValue)) {
                                FrameLayout grayFramLayout = new FrameLayout(context, attrs);
                                // 这里不采用自定义FrameLayout 解决webview显示问题
                                Paint mPaint = new Paint();
                                ColorMatrix cm = new ColorMatrix();
                                cm.setSaturation(0);
                                mPaint.setColorFilter(new ColorMatrixColorFilter(cm));
                                grayFramLayout.setLayerType(View.LAYER_TYPE_HARDWARE, mPaint);
                                // 替换掉根布局的FrameLayout 采用原生FrameLayout 无需自定义
                                return grayFramLayout;
                            }
                            
                        }
                        
                    }
                }
                return null;
            }
            
            @Override
            public View onCreateView(String name, Context context, AttributeSet attrs) {
                
                return null;
            }
        });
    }
    
   
};
registerActivityLifecycleCallbacks(mActivityLifecycleCallbacks);
```

优点：

* webview 黑白化后正常显示，通过FrameLayout 调用setLayerType解决
* 全面覆盖SDK内部activity，通过ActivityLifeCycleCallback 监听所有app 内打开的页面
* 兼容activity 基类不一致问题，兼容基类是Activity/AppCompatActivity/FragmentActivity
* 兼容dialog 黑白化处理，通过反射改变mFactorySet 值，可以重新调用setFactory2
* 无需自定义控件，用原生FrameLayout
* 无需在基类中做任何次改

weiview黑白化 效果图如下：

<img src="/img/app_web_gray.png" alt="alt" style="zoom:33%;" />

普通页面及dialog 效果图如下：

<img src="/img/app_dialog_gray.png" alt="alt" style="zoom:33%;" />



----

## 总结

​		方案一和方案二由于耗时久开发周期长，是肯定不会选的方案。方案三和方案四在特定场景下是可以选择，这个要看APP的实际需求。方案五目前来看是最优方案，兼容性强，建议采用。





参考博客链接：

<https://mp.weixin.qq.com/s/8fTWLYaPhi0to47EUmFd7A>

<https://mp.weixin.qq.com/s/EioJ8ogsCxQEFm44mKFiOQ>

<https://juejin.im/entry/5a140dc751882531bb6c7135>

