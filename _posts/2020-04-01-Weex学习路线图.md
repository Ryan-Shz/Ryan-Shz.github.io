---
layout: post
title: "Weex学习路线指引"
subtitle: "Android开发0基础学习Weex最短路径"
author: "YeZhongZheng"
tags:
  - Android 
  - Weex 
  - CSS 
  - javascript 
  - vue
---

# 一、 必备基础知识

## 1.1 css 

### 1.1.1 盒子模型

网页中和android中元素是一样的，每一个元素是由margin padding content组成，只是多了一个border 边框
![盒子模型](/img/weex/box.png)

为了方便理解，与android属性类比如下表：
| 作用   | android       | css                                                 |
| ------ | ------------- | --------------------------------------------------- |
| 宽     | layout_width  | width                                               |
| 高     | layout_height | height                                              |
| 外边距 | layout_margin | margin （marginTop 对应 margin-top 以此类推）       |
| 内边距 | padding       | padding (padding-right 对应 paddingRight，以此类推) |
| 背景   | background    | background-color or background-image                |
| 边框   | 无            | border                                              |

示例如下：
<img src="/img/weex/box.png" style="zoom:33%;"/>

下面是进阶案例，作为附加的，如果理解有困难，可以先忽略掉。我们对上面的例子改动一点，给父元素样式加上一个display属性值为block：
<img src="/img/weex/box-demo2.png" style="zoom:33%;" />

你定会很疑惑，为什么两个框之间的间隔从200变成了100。这里面需要额外知道几个概念：
  ​[display](https://blog.csdn.net/xuanwugang/article/details/80254401) 或 [display 参考手册](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)
  ​[外边框合并](https://cloud.tencent.com/developer/article/1495384)
理解了这两个概念后，再说一点，weex默认会把div设置成display flex ,而不是原本的display block。综合以上就能理解为什么第一个例子外边距没有按web默认的合并，而第二个例子手动加上display block后外边框发生了合并。

### 1.1.2 边框
android中不存在边框。css中默认height = content + padding + border

#### border-style
border-style设定边框样式，如果四个方向的边框样式不同，可分别设置：
- border-style {string}
- border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid
- border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid
- border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid
- border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid

支持的值如下：

- solid：实线边框，默认值 solid
- dashed：方形虚线边框
- dotted：圆点虚线边框

#### border-width
border-width：设定边框宽度，非负值, 默认值 0，如果四个方向的边框宽度不同，可分别设置：
- border-width {length}：非负值, 默认值 0
- border-left-width {length}：非负值, 默认值 0
- border-top-width {length}：非负值, 默认值 0
- border-right-width {length}：非负值, 默认值 0
- border-bottom-width {length}：非负值, 默认值 0

#### border-color
border-color：设定边框颜色，默认值 #000000，如果四个方向的边框颜色不同，可分别设置：
- border-color {color}：默认值 #000000
- border-left-color {color}：默认值 #000000
- border-top-color {color}：默认值 #000000
- border-right-color {color}：默认值 #000000
- border-bottom-color {color}：默认值 #000000

#### border-radius
border-radius：设置边框的圆角，默认值 0，如果四个方向的圆角弧度不同，可分别设置：
- border-radius {length}: 非负值, 默认值 0
- border-bottom-left-radius {length}：非负值, 默认值 0
- border-bottom-right-radius {length}：非负值, 默认值 0
- border-top-left-radius {length}：非负值, 默认值 0
- border-top-right-radius {length}：非负值, 默认值 0

示例如下
<img src="/img/weex/box-demo.png" />


### 1.1.3 文本样式

与android属性类比
| 作用                      | android                                                      | css                                                          |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 字体颜色                  | textColor                                                    | color                                                        |
| 文字大小                  | fontSize                                                     | font-size                                                    |
| 字体                      | font-style (可设置italic斜体,少了android的大写类别)          | font-style                                                   |
| 字体粗细程度              | 无直接对应，bold为true对应font-weight: bold                  | font-weight                                                  |
| 字体装饰（下划线 删除线） | 无直接对应，android需要代码设置                              | text-decoration （underline 下划线 line-through 删除线）     |
| 文本对齐                  | textAlignment                                                | text-align  （可选值 left                                    |
| 字体                      | fontFamily                                                   | font-family                                                  |
| 文本省略方式              | ellipsize (none 对应text-overflow为clip end对应text-overflow为ellipsis) | text-overflow (设置内容超长时的省略样式。可选值 clip 直接截取  ellipsis 截取并显示...) |
| 最大行数                  | lines                                                        | lines                                                        |
| 行高                      | lineHeight                                                   | line-height                                                  |
| 换行的方式                | 无对应                                                       | word-wrap（break-word                                        |

### 1.1.4 布局

#### 定位
为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标
- position {string}：设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。
  - relative 是weex默认值，指的是相对定位；
  - absolute 是绝对定位，以元素的容器作为参考系；
  - fixed 保证元素在页面窗口中的对应位置显示；
  - sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。
- top {number}：距离上方的偏移量，默认为 0。
- bottom {number}：距离下方的偏移量，默认为 0。
- left {number}：距离左方的偏移量，默认为 0。
- right {number}：距离右方的偏移量，默认为 0。

*说明：*
weex position默认是relative，可以理解成android的LinearLayout与RelativeLayout的结合。具体怎么理解，可以想象一个LinearLayout布局，然后元素再以自己原先的位置偏移。fixed 和absolute类似FrameLayout，只不过fixed父容器是整个窗口。具体看下面的案例：
<img src="/img/weex/relative.png" style="zoom:33%;" />
上面例子relative2和relative1发生了重叠，需要说明的是android中表现是overflow是hidden，所以超出框的文本不会显示。这点作为android开发是不难理解的。

### 1.1.5 FlexBox

weex布局默认是flex，flex是一种响应式的布局，特别灵活好用，google也提供了对应的[android实现库](https://github.com/google/flexbox-layout)
这块内容比较多,需要实际结合例子自己去体验下，详细的使用可以看[Flex 布局教程.语法](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)>和[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

## 1.2 JavaScript

javascript在网页的主要作用是操作html中的元素，不过weex中我们不需要用到这块，因为weex不存在真实的dom。下面主要介绍weex中会用到的js基础知识。

### 1.2.1 数据类型

#### 类型汇总

```javascript
var length = 7;                             // 数字 android中的int long double在js只有一个类型就是数值
var lastName = "Gates";                     // 字符串
var cars = ["Porsche", "Volvo", "BMW"];     // 数组
var x = {                                   // 对象
    firstName:"Bill", 
    lastName:"Gates", 
    myMethod: function (param) {
        console.log(param + this.firstName + this.lastName)
    }
};
var isLegal = false; // 布尔类型 true false
var currentDate = new Date(); // 日期类型
var test = null; // 空值对象
var test; // 未赋值会是 undefined

cars[0] = "lory"; // 数组取值赋值
x.myMethod("test:"); // 调用对象中的方法，将输出 test:BillGates
```

#### js是动态类型，变量赋值后还可以修改类型,如下都是可以的
  
```javascript
 var length= 7;                             // 初始是数值
 length = "0";                               // 可再赋值为其他类型
```

#### 自动类型转换

```javascript
 5 + null    // 返回 5         因为 null 被转换为 0
 "5" + null  // 返回 "5null"   因为 null 被转换为  "null"
 "5" + 2     // 返回 52        因为 2 被转换为 "2"
 "5" - 2     // 返回 3         因为 "5" 被转换为 5
 "5" * "2"   // 返回 10        因为 "5" 和 "2" 被转换为 5 和 2
```

#### js中所有不具有“真实”值的即为 False，怎么理解，看下面的例子

```javascript
 var length = 0; 
 if (length) {
     console.log("true");
 }
 length = "";
 if (length) {
     console.log("true");
 }
 let len;
 if (len) {
     console.log("true");
 }
 var x = 10 / "H";
 if (x) {
     console.log("true");
 }
 执行上述js，会发现都没有走到if判断里面，说明都被解析成了false
```

### 1.2.2 声明变量 与 注释

```javascript
  /* 我是变量注释 */
  var value2 = "value2";
  // 我是块作用域变量注释，优先使用
  let value1 = 'value1';
  // 我是常量
```

说明：js是弱类型语言，不需要像java在声明变量时候指定类型。let和var都可以声明变量，只不过let具有更小的作用范围，是块作用域。看下面代码：

```javascript
  {
      let value1 = 1;
  }
  console.log("value1:" + value1);
  // 执行会报错，因为value1的作用域在方法块里面
```

### 1.2.3 基础逻辑判断(这里仅列下和java有区别的部分)

#### 比较运算符
js中特有 === !==,表示不仅比较值，类型也会校验，看下面的例子

```javascript
var a = 1;
var b = "1"
if (a == b) { // 会执行打印true
  console.log("true");
}
if (a === b) { // 不会执行打印true
  console.log("true");
}
```

#### For In 循环
for in 和java的不同在于，不是直接返回条目而是index,如下：
```javascript
let arrs = [1,3,3,4,4];
for(i in arrs) {
  console.log(i + " ") // 将打印 0 1 2 3 4
}
// for in循环还可以用于循环获取对象属性
var person = {fname:"Bill", lname:"Gates", age:62}; 
for (x in person) {
  console.log(x + " "); // 将打印fname lname age
}
```

### 1.2.4 数组

```javascript
let arrs = [1, 3];
var x = arrs.length;   // length 属性返回元素的数量 [2]
var y = arrs.sort();   // sort() 方法对数组进行排序 
arrs.push(5);         // 向 arrs 添加一个新元素 (5) [1, 2, 3]
arrs.pop();          // 移除最后一个元素 [1, 2]
arrs.shift();        // 删除第一个元素 [2]
arrs.unshift("3")     // 新增元素到顶部，并把之前第一个元素移到末尾 [3, 2]
arrs.splice(1, 1, 4, 6) // 从第一位后删除一个元素，同时添加4和6到第一位后 ["3", 4, 6]
let arrs2 = [1, 3];
let newArr = arrs.concat(arrs2); // 合并一个新数组  ["3", 4, 6, 1, 3]
let tmpArr = arrs.slice(1, 2); // 从原数组中从1位截取两个元素生成新数组 返回  
```

### 1.2.5 ES5
可以以java的版本来理解，下面介绍一些ES5中新增的开发中好用的方法

#### forEach
之前提到for in 返回的是index ,forEach方法才是java中的for in 循环
```javascript
var numbers = [45, 4];
numbers.forEach(myFunction);
function myFunction(value) {
  console.log(value);
}
// 输出45 4
```

#### map
可以理解成RxJava中的map

```javascript
var numbers1 = [45, 4];
var numbers2 = numbers1.map(myFunction);
function myFunction(value) {
  return value * 2;
}
// 将输出一个值为[90, 8]的数组
```

#### filter
同RxJava中的filter

```javascript
let arrs = [1,3,3,4,4];
var largeThanTwoArr = arrs.filter(bigThan);
function bigThan(value) {
  return value > 2;
}
// 数组将变成[3,3,4,4]
```

#### 其他

```javascript
let arrs = [1,3,3,4,4];
arrs.indexOf(3) // 返回1
arrs.lastIndexOf(3) // 返回2
let jsonStr = '{"name":"Bill", "age":62, "city":"Seatle"}'; // json字符串
let jsonObj = JSON.parse(jsonStr); //解析json字符串为json对象
let jsonStr = JSON.stringify(jsonObj) // 将json对象反转成json字符串
let arrs = [1,3,3,4,4];
for(i in arrs) {
  console.log(i + " ") // 将打印 0 1 2 3 4
}
// for in循环还可以用于循环获取对象属性
var person = {fname:"Bill", lname:"Gates", age:62}; 
for (x in person) {
  console.log(x + " "); // 将打印fname lname age
}

```

### 1.2.7 ES6

#### 箭头函数
类似java中的lambo表达式，可以简写很多代码，如下：

 ```javascript
  // ES5
  var x = function(x, y) {
    return x * y;
  }
  // ES6
  const x = (x, y) => x * y;
 ```

### 1.2.8 闭包
JavaScript 变量属于函数或全局作用域。全局变量能够通过闭包实现局部（私有）。作为js中一个比较重要的高阶概念，后续会有用到，单独介绍下：

```javacript
// 初始化计数器
var counter = 0;

// 递增计数器的函数
function add() {
	counter += 1;
}
// 调用三次 add()
add();
add();
add();
// 此时计数器应该是 3
上述解决方案有一个问题：页面上的任何代码都可以更改计数器，而无需调用 add()，如何解决上面的问题呢JavaScript 支持嵌套函数。嵌套函数可以访问其上的作用域，如下

function add() {
    var counter = 0;
    function plus() {counter += 1;}
    plus()
    return counter;
}

​但是有一个新的问题，我们怎么访问plus函数，这里就用到了闭包

var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();  // 这里用到了自运行函数,(function () { cosole.log("我是函数") })() ,这样函数会自运行。可以以java中的匿名类调用做类比
add();
add();
add();
// 计数器目前是 3
```

## 1.3、VUE

### Vue是什么

简单说[Vue](https://cn.vuejs.org/v2/guide/index.html)是一个js库，它实现了类似android mvvm的数据驱动界面，能够以组件形式高效的构建用户界面。

基本原理，vue在原有html DOM树之上增加了一层虚拟DOM，每次数据发送变化驱动虚拟dom计算差异值，最终根据差异值去驱动DOM树做出改变，真实DOM树的改变会驱使网页重新渲染。
<img src="/img/weex/vue.png" style="zoom:33%;" />
ps：这样做的好处：1，真实的dom改变每次都会驱动界面刷新，虚拟dom的引入可以减少改变的次数，从而提升性能； 2，真实的dom操作较为繁琐，避免了操作真实dom； 3，从软件整体架构上虚拟dom的引入避免了强依赖，为扩展带来了可能性。例如vue的逻辑在最终绑定界面是不绑定真实dom，而是把虚拟dom交给客户端渲染，这就是weex的基本原理。下面对vue的重要特性进行介绍：
  
#### 声明式渲染
可以通过一个简洁的模板语法声明式的将数据渲染出
[Hello Vue例子](https://jsfiddle.net/chrisvfritz/50wL7mdz/)

#### 条件语句
可以轻松的控制元素是否显示

```javacript
<div id="app-3">
  <p v-if="seen">现在你看到我了</p>
</div>

var app3 = new Vue({
  el: '#app-3',
  data: {
        seen: true
  }
})
// 把seen改为false，p元素就会被隐藏
```

####循环语句
根据提供的数据批量添加子元素

```javascript
<div id="app-4">
  <ol>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ol>
</div>

var app4 = new Vue({
  el: '#app-4',
  data: {
  	todos: [
  	  { text: '学习 JavaScript' },
  	  { text: '学习 Vue' },
  	  { text: '整个牛项目' } ]
  }
})

将在网页中渲染出列表：
1. 学习 JavaScript
2. 学习 Vue
3. 整个牛项目
```

#### 组件生产周期
vue实现了组件化，每一个组件都有它的声明周期，这块如果理解不了可以暂时不管，了解即可。
<img src="/img/weex/lifecycle.png" alt="lifecycle" style="zoom: 25%;" />

#### Prop
组件之前也是一个树结构，有些场景需要把父组件的值传递给子组件，这个时候就用到了Prop。

```javascript
// 父组件包含了子组件my-component，怎么把自己的title属性传递给子组件呢
<div id="components-demo">
  <my-component :title="post.title"></my-component> // 加:表示计算表达式
  <my-component title="i am title"></my-component> // 也可以去掉: 直接传递字符串
</div>
new Vue({
  el: '#blog-post-demo',
  data: {
    post: { id: 1, title: 'My journey with Vue' }
  }
})
```
需要特别说明的是vue的数据传递是单向的，当父容器的属性发生变化时，会触发子元素的更新，但是反过来不会（对象会有影响，因为对象是引用类型，这个和java是一样的。为了避免子组件对父组件的影响，对象的情况需要进行深拷贝处理）

#### 事件处理
v-on:click给元素添加点击事件

```javascript
<div id="example-3">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say">empty msg</button>
</div>
new Vue({
  el: '#example-3',
  methods: {
    say: function (message) {
      alert(message ？ message : "empty msg");
    }
  }
})
```
补充说明：js的[事件模型](https://blog.csdn.net/qq_39771710/article/details/88822276?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)分两个级别，DOM0和DOM2，DOM2的事件分为两个阶段捕获和冒泡，这个和原生的处理方式不一样。但是由于weex毕竟最终是原生，所以并不支持js本身的这两个阶段。

#### v-model
提供一种简单的获取表单控件（输入框）值的

```javascript
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
/* 上面这个例子input输入框的输入和message会进行绑定，当输入文字时，
meesage的值会改变，从而驱动<p>中文本的改变 */
```

# 二、 入门开发

## 2.1 开发环境配置

### [node](https://nodejs.org/en/?spm=a2c7j.-zh-guide-develop-setup-develop-environment.0.0.17045ef7rjX0gb)

node是独立的js运行环境，本来js只能运行在浏览器中，node抽离了js运行环境，使得js可以独立运行。如果想详细了解看[教程](https://www.runoob.com/nodejs/nodejs-tutorial.html)

### pm
npm是随Node安装的包管理工具
可以考虑把npm的镜像设置成淘宝的镜像，速度会更快些。
```ruby
npm config set registry https://registry.npm.taobao.org
```

### weex-cli

运行在node上的weex脚手架工具，可以通过命令创建weex项目。使用npm安装，如下：

```ruby
$ sudo chmod -R 777 /usr/local/lib/node_modules/
$ npm i -g weex-toolkit // 安装不要使用sudo执行
$ weex -v // 查看当前weex工具版本
```

### 开发工具

建议使用[VsCode](https://code.visualstudio.com/download)，下载安装后再安装[weex相关的插件](https://weex.apache.org/zh/tools/extension.html#功能)

### 2.2 创建运行weex工程

执行 `weex create weex-demo1`,开始创建工程，会提示你选择，简单介绍下各个选项的作用：

Project name (weex-demo)  工程名
? Project description (A weex project) 工程描述
? Author (11091417 <yezhongzheng@bbktel.com>) 作者
Select weex web render： weex web端的渲染模块的版本
Babel compiler： 语法的选择，默认的stage-0，支持es6的语法
? Use vue-router to manage your view router? (not recommended) (y/N) :  weex默认是单页面的，意味页面跳转都是打开新的weex页面，vue-router可以在单页面上实现多页面的效果
? Use ESLint to lint your code? (Y/n)： 语法检查
? Set up unit tests (Y/n) ： 单元测试
? Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys) ：  工程创建后是否自动运行npm install（下载相关依赖包）


创建成功后会提示你可以运行的命令，这里不做解释，注释本身写的比较好。创建的工程用VsCode打开后目录如下,涉及较多前端的东西稍微理解下即可：


| 目录                      | 作用                               |
| ------------------------- | ------------------------------------------|
| configs | 配置文件| 
| node_modules | 依赖库| 
| platforms | android 和ios的代码，默认为空，需要执行命令添加对应平台| 
| plugins|  插件| 
| src|  主工程，开发目录| 
| test|  单元测试| 
| web | 默认启动服务后的web页面| 
| .babelrc|   用到的js语法支持配置| 
| .eslintignore|  语法检查的忽略文件| 
|  .eslintrc.js |  语法检查的配置| 
| .postcssrc.js | postcss的插件，可以自动帮忙补齐一些css属性，处理兼容性问题| 
| android.config.json  | android工程的基础信息appid等| 
| ios.config.json | | 
| pakage-lock.json | 锁定所有模块的版本号，包括主模块和所有依赖子模块| 
| Package.json|   记录你项目中所需要的所有模块| 
| webpack.config|  打包相关的配置| 

<img src="/img/weex/newproject.png" style="zoom:33%;" />

### 运行工程

执行`npm start`效果如下：
下载Weex playground app安装后扫描下面的二维码可以在真机中看到效果

<img src="/img/weex/code.png" style="zoom:33%;" />

#### 添加android工程

默认不带有android工程，可以通过`weex platform add android`
打开工程下的platforms发现多了一个android 目录，里面其实就是一个android app。你可以用as打开这个工程运行或者执行 `weex run android`

#### 开发目录src介绍

<img src="/img/weex/project.png" style="zoom:33%;" />

entry.js 是入口，可以理解成android中的application。index.vue是入口页面，其中依赖了组件HelloWorld.vue

### 2.3 基础控件

基础组价部分[官方文档](https://weex.apache.org/zh/docs/components)比较好，不做详细描述,简单描述下组件功能

| 标签         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| a            | 跳转连接                                                     |
| div          | 容器，可以理解成Layout，加载对应的css属性后对应Linarlayout或者FrameLayout |
| text         | 文档                                                         |
| image        | 图片                                                         |
| list         | 可以理解成ListView                                           |
| cell         | list的元素                                                   |
| loading      | 加载更多，配合list scroller waterfall使用                    |
| refresh      | 下拉刷新，配合list scroller waterfall使用                    |
| recycle-list | 可以理解成RecylerView,但是不支持下拉刷新                     |
| scroller     | 同ScrollView                                                 |
| slider       | 可理解成ViewPager，用于实现广告位                            |
| indicater    | 配合slider，显示下面的角标                                   |
| textarea     | 多行输入                                                     |
| input        | 单行输入                                                     |
| waterfall    | 瀑布流                                                       |
| video        | 视频                                                         |
| web          | 可理解为webview                                              |
| richtext     | 富文本                                                       |

### 2.4 基础模块

- [网络请求](https://weex.apache.org/zh/docs/modules/stream.html#fetch)

可结合下面的第一个实例去看

- 跳转

  - a标签实现跳转

  - [navigator](https://weex.apache.org/zh/docs/modules/navigator.html#push)实现跳转

  - vue-router实现跳转
   Vue-router只是单页面模拟的跳转效果，原生中还在一个activity，可以理解成fragment

- [数据存储](https://weex.apache.org/zh/docs/modules/storage.html#setitem)

### 2.5 第一个实例页面

Weex基础组件和模块这块官网讲的比较好，还有示例，不做过多的描述。下面介绍一个完整的[项目示例](https://github.com/Ryan-Shz/weex-demo)。说明下Weex本来只是用来开发单页面的，示例中用到了支持库[vue-router](https://router.vuejs.org/zh/installation.html) 来支持多页面切换的效果。项目中还涉及了[scss](https://juejin.im/post/5cf488ea518825378867758f)。 Vue-router和scss不是必须内容，如果不感兴趣可以暂时忽略掉，了解什么作用即可。


> [自学资料](https://www.w3school.com.cn/)
