---
layout: post
title: "Handler实现原理"
subtitle: "从源码角度解析Android消息机制"
author: "SuJiPeng"
tags:
  - Android
---

## Handler实现原理

Handler是Android消息处理机制的上层接口，Android消息处理机制本质上就是一个线程不断地从消息队列中获取消息，并进行处理的机制。其应用场景主要是：有时需要在子线程中进行一些耗时的I/O操作，当耗时操作执行完毕之后需要在主线程中更新UI，此时就可以使用handler将更新UI的操作切换到主线程中执行。handler是如何将一个操作切换到指定的任务中执行的呢？

#### Handler消息处理机制

handler在底层是由MessageQueue以及Looper支持的。Android消息处理机制的流程图如下图所示：

![Android消息处理机制](/img/in-post/handler.png)

根据上图，Android的消息处理机制是由`Handler`、`Looper`、`MessageQueue`等协调配合实现的。具体的消息处理流程如下：

##### 工作线程发送消息

工作线程在任务执行完成后，通过Handler对象（调用`sendMessage` 、`post`等方法）向Looper线程发送消息，此时会将消息插入到消息队列`MessageQueue`中。各种sendMessage方法最后都会调用`sendMessageAtTime`方法，`sendMessageAtTime`方法的源码如下：

```java
public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
```

```java
private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
        long uptimeMillis) {
    msg.target = this;
    msg.workSourceUid = ThreadLocalWorkSource.getUid();

    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
```

可以看到最终是调用`MessageQueue.enqueueMessage`方法将消息添加到消息队列`MessageQueue`中。另外需要注意的一点是：在将`Message`对象添加到队列之前，会将其target属性赋值为当前发送此`Message`的`Handler`对象，从而将`Message`对象与发送该消息的`Handler`对象绑定。当Looper取出消息时，可以直接通过target属性调用`Handler`的`dispatchMessage`方法完成对消息的处理，这个后面再具体分析。

我们常用的`post`方法，其传入的Runnable对象也会被封装成Message对象，最终也是调用`sendMessageAtTime`方法将消息插入到消息队列中。

```java
public final boolean post(@NonNull Runnable r) {
   return  sendMessageDelayed(getPostMessage(r), 0);
}
```

```java
private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
```

另外，我们看一下Handler对象的实例化。Handler重载的各种构造函数最终调用下面的函数完成Handler的实例化：

```java
public Handler(@Nullable Callback callback, boolean async) {
    ...
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            "Can't create handler inside thread " + Thread.currentThread()
                    + " that has not called Looper.prepare()");
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
```

在创建Handler对象的过程中，首先获取当前线程的Looper对象，**如果此时没有创建Looper对象，将会抛出异常**。因此，我们在一个线程中实例化Handler对象之前，应该首先创建Looper对象，否则将抛出异常。在平常的开发过程中，我们在主线程中实例化Handler之前**不需要也不能**创建Looper对象也不会抛出异常的原因是主线程在创建之初就创建了Looper对象并且开启循环，而且重复创建也会抛出异常。`ActivityThread`是主线程的入口类，在该类的入口方法`main`中完成了Looper的实例化工作，其源码如下：。

```java
public static void main(String[] args) {
    
    ...

    Process.setArgV0("<pre-initialized>");

    // 初始化主线程looper
    Looper.prepareMainLooper();

  	...
        
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, "ActivityThread"));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // 开始轮询
    Looper.loop();

    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

因此，如果在非主线程中创建Hander对象，在创建之前一定要记得先创建Looper对象，否则将会抛出异常。

##### 添加消息到消息队列

上文我们看到，`Handler`发送消息实质上就是将消息插入到`MessageQueue`中。`MessageQueue`是用来存储消息的消息队列，Looper将不断地从该队列中取出消息进行处理。虽然名字叫做队列，但其数据结构本质上是一个**单链表**。下面我们分析下将消息插入消息队列的过程。

```java
boolean enqueueMessage(Message msg, long when) {
    //target不允许为空，否则将抛出异常
    if (msg.target == null) {
        throw new IllegalArgumentException("Message must have a target.");
    }
    // 如果队列中已经存在于队列中，将抛出异常
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + " This message is already in use.");
    }

    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + " sending message to a Handler on a dead thread");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        // 标志消息已经在队列中了
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
```

从插入队列的实现上来看，就是将一个`Message`对象按照**消息所执行时间点**的先后顺序插入到单链表合适的位置中。因此，消息队列是按照`Message`的执行时刻排序的。

`Message`的target属性不能为空，否则会抛出异常。

##### 消息的处理

消息的处理是由`Looper`实现的。`Looper`不停地查看`MessageQueue`中是否有消息需要处理，如果有则立即处理，没有将会阻塞。首先先看一下`Looper`的构造方法。

```java
private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
```

在`Looper`的构造方法中会创建一个`MessageQueue`对象，并把当前线程对象保存起来。另外，我们注意到这个构造方法是私有的，因此我们不能直接通过构造方法来创建`Looper`，我们需要通过下面的方法来创建`Looper`对象：

```java
public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}


public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException("The main Looper has already been prepared.");
        }
        sMainLooper = myLooper();
    }
}

public static Looper getMainLooper() {
    synchronized (Looper.class) {
        return sMainLooper;
    }
}

public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
```

```java
// sThreadLocal.get() will return null unless you've called prepare().
@UnsupportedAppUsage
static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
@UnsupportedAppUsage
private static Looper sMainLooper;  // guarded by Looper.class
```

在`prepare`方法中，会将创建的`Looper`对象存入`Looper`类的一个静态`ThreadLocal`中，并且每个线程只能有一个`Looper`对象，重复创建`Looper`对象会抛出异常。

因为Looper的作用域仅限于线程且每个线程需要一个副本，因此使用`ThreadLocal`可以实现访问同一个静态变量`sThreadLocal`的线程都会存在一个`Looper`副本，每个线程互不干扰。下面简单介绍一下`ThreadLocal`的原理。

###### 插播一段——ThreadLocal介绍

> ThreadLocal 提供了线程本地的实例。这些变量与普通的对应变量不同，因为每个访问同一个变量的线程(通过其get或set方法)都有自己独立初始化的变量副本。当一个线程结束时，它所使用的所有 ThreadLocal 相对应的实例副本都可被回收。

![ThreadLocal原理图](/img/in-post/ThreadLocal.png)

每个Thread中都维护一个`ThreadLocalMap`，该Map维护`ThreadLocal`对象和其对应value的映射关系。当调用`get`或者`set`方法时，都会获取当前线程的`ThreadLocalMap`对象，然后以当前`ThreadLocal`对象为key在`ThreadLocalMap`中查找或设置当前`ThreadLocal`对象所对应的value。这样就保证了每个线程中都保存一个`ThreadLocal`相对应的实例变量的副本。首先看下其`get`方法的实现：

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

首先通过`getMap(t)`获取当前线程的ThreadLocalMap对象，然后通过`getEntry(this)`获取当前ThreadLocal对象Entry对象。如果获取到的`ThreadLocalMap.Entry`不空，返回对应的value。如果ThreadLocalMap为空或`ThreadLocalMap.Entry`则说明当前线程中不存在当前ThreadLocal对应的value，调用`setInitialValue()`初始化设置。

```java
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

```java
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

`ThreadLocal`的`set`方法实现如下：

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

###### 获取消息以及消息的处理

由于主线程的`Looper`的特殊性，`Looper`提供了`prepareMainLooper`方法用来创建主线程的`Looper`，这个方法是由Android系统去调用的，我们不应该去调用这个方法，否则将会因为重复创建`Looper`抛出异常。此外还提供了一个`getMainLooper`方法，通过该方法，我们可以在任何地方获取主线程的`Looper`。

上面我们讲到其他线程通过Handler将消息添加到`MessageQueue`，`MessageQueue`中的消息将由`Looper`进行处理：`Looper`会不停的获取消息队列中的消息。消息的轮询是由`loop`方法实现的：

```java
/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    //获取当前线程的looper对象
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride =
            SystemProperties.getInt("log.looper."
                    + Process.myUid() + "."
                    + Thread.currentThread().getName()
                    + ".slow", 0);

    boolean slowDeliveryDetected = false;
    // 死循环
    for (;;) {
        // 从消息队列中取出一个消息
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;

        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);

        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;

        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }

        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            // 处理消息
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery",
                        msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x"
                    + Long.toHexString(ident) + " to 0x"
                    + Long.toHexString(newIdent) + " while dispatching to "
                    + msg.target.getClass().getName() + " "
                    + msg.callback + " what=" + msg.what);
        }
        // 回收消息对象
        msg.recycleUnchecked();
    }
}
```

1. `loop`方法首先会获取当前线程的`Looper`对象，如果在调用`loop`方法之前未创建`Looper`对象，将会抛出异常。

2. 接着通过一个for循环开启无限循环模式，调用`MessageQueue`的`next`方法从消息队列中获取一个消息，如果消息队列中没有消息，那么`next`方法将会阻塞。下面分析下`next`方法的实现：

   ```java
   Message next() {
       // Return here if the message loop has already quit and been disposed.
       // This can happen if the application tries to restart a looper after quit
       // which is not supported.
       final long ptr = mPtr;
       if (ptr == 0) {
           return null;
       }
   
       int pendingIdleHandlerCount = -1; // -1 only during first iteration
       int nextPollTimeoutMillis = 0;
       for (;;) {
           if (nextPollTimeoutMillis != 0) {
               Binder.flushPendingCommands();
           }
   		//读取消息，队列里没有消息有可能会堵塞，两种情况该方法才会返回(代码才能往下执行)
           //一种是等到有消息产生就会返回,
           //另一种是当等了nextPollTimeoutMillis时长后，nativePollOnce也会返回
           nativePollOnce(ptr, nextPollTimeoutMillis);
   
           synchronized (this) {
               // Try to retrieve the next message.  Return if found.
               final long now = SystemClock.uptimeMillis();
               Message prevMsg = null;
               Message msg = mMessages;
               if (msg != null && msg.target == null) {
                   // Stalled by a barrier.  Find the next asynchronous message in the queue.
                   do {
                       prevMsg = msg;
                       msg = msg.next;
                   } while (msg != null && !msg.isAsynchronous());
               }
               if (msg != null) {
                   if (now < msg.when) {
                       // Next message is not ready.  Set a timeout to wake up when it is ready.
                       nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                   } else {
                       // Got a message.
                       mBlocked = false;
                       if (prevMsg != null) {
                           prevMsg.next = msg.next;
                       } else {
                           mMessages = msg.next;
                       }
                       msg.next = null;
                       if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                       msg.markInUse();
                       return msg;
                   }
               } else {
                   // No more messages.
                   nextPollTimeoutMillis = -1;
               }
   
               // Process the quit message now that all pending messages have been handled.
               if (mQuitting) {
                   dispose();
                   return null;
               }
   
               // If first time idle, then get the number of idlers to run.
               // Idle handles only run if the queue is empty or if the first message
               // in the queue (possibly a barrier) is due to be handled in the future.
               if (pendingIdleHandlerCount < 0
                       && (mMessages == null || now < mMessages.when)) {
                   pendingIdleHandlerCount = mIdleHandlers.size();
               }
               if (pendingIdleHandlerCount <= 0) {
                   // No idle handlers to run.  Loop and wait some more.
                   mBlocked = true;
                   continue;
               }
   
               if (mPendingIdleHandlers == null) {
                   mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
               }
               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
           }
   
           // Run the idle handlers.
           // We only ever reach this code block during the first iteration.
           for (int i = 0; i < pendingIdleHandlerCount; i++) {
               final IdleHandler idler = mPendingIdleHandlers[i];
               mPendingIdleHandlers[i] = null; // release the reference to the handler
   
               boolean keep = false;
               try {
                   keep = idler.queueIdle();
               } catch (Throwable t) {
                   Log.wtf(TAG, "IdleHandler threw exception", t);
               }
   
               if (!keep) {
                   synchronized (this) {
                       mIdleHandlers.remove(idler);
                   }
               }
           }
   
           // Reset the idle handler count to 0 so we do not run them again.
           pendingIdleHandlerCount = 0;
   
           // While calling an idle handler, a new message could have been delivered
           // so go back and look again for a pending message without waiting.
           nextPollTimeoutMillis = 0;
       }
   }
   ```

   其大致执行流程为：

   ![](/img/in-post/MessageQueue-next-color.png)

   **IdleHandler介绍**

   `IdleHandler`是如果当线程中消息中没有消息，或者消息队列中存在消息，但是最早要执行的消息也在未来时刻执行时，此时将会执行的`IdleHandler`中`queueIdle`方法中所定义的操作。`IdleHandler`的定义如下。`queueIdle`返回true时，表示`IdleHandler`仍然保留在队列中，否则，当`queueIdle`执行完毕时会将`IdleHandler`从队列中移除。具体实现参考`next`方法源码。

   ```java
   /**
    * Callback interface for discovering when a thread is going to block
    * waiting for more messages.
    */
   public static interface IdleHandler {
       /**
        * Called when the message queue has run out of messages and will now
        * wait for more.  Return true to keep your idle handler active, false
        * to have it removed.  This may be called if there are still messages
        * pending in the queue, but they are all scheduled to be dispatched
        * after the current time.
        */
       boolean queueIdle();
   }
   ```

   另外，通过阅读`next`方法源码，我们可以看到`IdleHandler`只会在`next`中for循环的第一次循环时执行，`IdleHandler`执行完毕之后，会将`pendingIdleHandlerCount`置为0，之后的循环将不会处理`IdleHandler`。

   通过调用`addIdleHandler`方法将`IdleHandler`添加到`mIdleHandlers`，`mIdleHandlers`是一个`ArrayList`。

   ```java
   private final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();
   ```

   ```java
   public void addIdleHandler(@NonNull IdleHandler handler) {
       if (handler == null) {
           throw new NullPointerException("Can't add a null IdleHandler");
       }
       synchronized (this) {
           mIdleHandlers.add(handler);
       }
   }
   ```
   
   回到`loop`方法，当获取到一个消息后，通过`Message`的`target`属性，执行`handler`对象的`dispatchMessage`方法，实现对我们定义的消息处理流程的回调。`dispatchMessage`的是实现如下：
   
   ```java
   /**
    * Handle system messages here.
    */
   public void dispatchMessage(@NonNull Message msg) {
       if (msg.callback != null) {
           handleCallback(msg);
    } else {
           if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                   return;
               }
           }
           handleMessage(msg);
       }
   }
   ```
   
   消息的处理有一个优先级顺序：
   
   - 优先级最高的是Message的Callback。当我们用`Handler.post(Runnable r)`方法发送一个消息的时候，其实就是将我们指定的Runnable对象封装在了Message对象的Callback属性中。`handleCallback(msg)`实现为：
   
     ```java
     private static void handleCallback(Message message) {
         message.callback.run();
     }
     ```

   - 其次为`Handler`自己的`mCallback`对象。我们在实例化`Handler`的时候可以传入一个`Callback`。

     ```java
    public Handler(@Nullable Callback callback) {
         this(callback, false);
     }
     ```
   
   - 处理优先级最低的是`Handler`自身的`handleMessage`方法。

3. 回收`Message`对象。消息执行完成后将会回收消息对象，消息对象的回收由`recycleUnchecked`方法实现：

   ```java
   /**
    * Recycles a Message that may be in-use.
    * Used internally by the MessageQueue and Looper when disposing of queued Messages.
    */
   @UnsupportedAppUsage
   void recycleUnchecked() {
       // Mark the message as in use while it remains in the recycled object pool.
       // Clear out all other details.
       flags = FLAG_IN_USE;
       what = 0;
       arg1 = 0;
       arg2 = 0;
       obj = null;
       replyTo = null;
       sendingUid = UID_NONE;
       workSourceUid = UID_NONE;
       when = 0;
       target = null;
       callback = null;
       data = null;
   
       synchronized (sPoolSync) {
           if (sPoolSize < MAX_POOL_SIZE) {
               next = sPool;
               sPool = this;
               sPoolSize++;
           }
       }
   }
   ```

   从中我们可以看到，`Message`类中会维护一个静态的消息对象池`sPool`，当消息处理完成之后，会将`Message`对象置为初始状态，接着如果`sPool`中消息对象的数目未达到最大，会将该`Message`对象放入消息对象池中（插入链表）。

   使用`Message`对象池的目的就是复用`Message`对象。 因此，我们在创建`Message`对象的时候，不要直接使用new的方式创建对象，而是应该通过`Message`类提供的静态方法`obtain`获取`Message`对象，已达到对象复用的目的。其实如下，优先从`sPool`中获取`Message`对象，只有当`sPool`为空的时候才去创建一个新的对象。

   ```java
   /**
    * Return a new Message instance from the global pool. Allows us to
    * avoid allocating new objects in many cases.
    */
   public static Message obtain() {
       synchronized (sPoolSync) {
           if (sPool != null) {
               Message m = sPool;
               sPool = m.next;
               m.next = null;
               m.flags = 0; // clear in-use flag
               sPoolSize--;
               return m;
           }
       }
       return new Message();
   }
   ```

4. 最后需要注意的是，`loop`方法是一个无限循环，除非消息队列退出。因此，如果我们在子线程中使用Handler处理消息时，如果确定已经不需要处理消息时，则主动将Looper退出，退出的方法如下：

   ```java
   
   public void quit() {
       mQueue.quit(false);
   }
   
   public void quitSafely() {
       mQueue.quit(true);
   }
   ```
   
   这两个方法都是调用`MessageQueue.quit`方法。在这个方法中将`mQuitting`置为true，在`MessageQueue.next`方法中如果`mQuitting`为true将会返回null，此时`Looper.loop`方法在调用`MessageQueue.next`返回null时将会结束循环。
   
   ```java
   void quit(boolean safe) {
       if (!mQuitAllowed) {
           throw new IllegalStateException("Main thread not allowed to quit.");
       }
   
       synchronized (this) {
           if (mQuitting) {
               return;
           }
           mQuitting = true;
   
           if (safe) {
               removeAllFutureMessagesLocked();
           } else {
               removeAllMessagesLocked();
           }
   
           // We can assume mPtr != 0 because mQuitting was previously false.
           nativeWake(mPtr);
       }
   }
   ```
   


#### 总结

1. 主线程中不需要创建Looper对象，因为主线程在线程初始化的时候已经创建了Looper对象，同一个线程里，最多只能有一个Looper对象，重复创建将会抛出异常。而在其他子线程中需要处理消息时，要记得先创建Looper对象，因为非主线程默认不会创建Looper对象。
2. 只有调用了`Looper.loop()`方法，消息机制才会正常工作，因为消息的获取、处理都是由在`loop`来协调的。
3. `Looper.loop()`方法一定要在调用`Looper.prepare()`之后调用。因为如果当前线程还没有Looper，调用`Looper.loop()`方法会抛出异常。
4. 在子线程中使用Handler时，当Handler不需要处理消息时，记得手动调用`Looper.quit`或者`Looper.quitSate`结束循环。
5. 创建消息时用`Message.obtain`节省内存。

